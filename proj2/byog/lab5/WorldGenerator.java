// add hallway, continue

package byog.lab5;

import byog.TileEngine.TETile;
import byog.TileEngine.Tileset;

import java.util.Random;
import java.lang.Math;

public class WorldGenerator {

    /**
     * Try to generate a world using existing library.
     */
    private static final int WIDTH = 80;
    private static final int HEIGHT = 50;
    private int SEED;
    private static final Random RANDOM = new Random();

    /* accept an integer as a seed for generating world
     * @param seed: the integer should be from player's input
     */
    public WorldGenerator(int seed) {
        this.SEED = seed;
    }

    // default seed is 0 if input is none
    public WorldGenerator() {
        this.SEED = 0;
    }

    public TETile[][] generateRandomWorld(TETile[][] world) {
        TETile[][] temp = worldInit(world);             // initialize world with NOTHING on each tile
        temp = addRooms(temp);                          // add rooms on the map
        temp = addHallways(temp);   // add hallway connecting rooms on the map
        return temp;
    }
    /* filled world with square room with random size, and location, number of rooms are determined by attempts
     * rooms shouldn't overlap each other
     * @param world - TETile[][] 2D array
     * @param attempts - try to
     */

    public TETile[][] addRooms(TETile[][] world) {
        int numberOfRooms = 100000;
        int roomWIDTHmin = 3;       // set room minimum width to 2
        int roomWIDTHmax = 30;       // set room maximum width to 8
        int roomHEIGHTmin = 3;      // set room minimum height to 2
        int roomHEIGHTmax = 15;      // set room maximum height to 6
        while (numberOfRooms > 0) {
            int rowPos = RANDOM.nextInt(HEIGHT);
            int colPos = RANDOM.nextInt(WIDTH);
            int roomWIDTH = RANDOM.nextInt(roomWIDTHmax - roomWIDTHmin) + roomWIDTHmin;
            int roomHEIGHT = RANDOM.nextInt(roomHEIGHTmax - roomHEIGHTmin) + roomWIDTHmin;
            addRoom(world, rowPos, colPos, roomWIDTH, roomHEIGHT);
            numberOfRooms--;
        }
        return world;
    }

    /* add one room in the world with provided location, room width and height */
    public void addRoom(TETile[][] world, int row, int col, int roomWIDTH, int roomHEIGHT) {
        /* offset can affect the distribution of squares in the map
         * offset = -1 - rooms overlap
         * offset = 0 - it is possible that there is no space between two rooms
         * offset = 1 - rooms are isolated, at least 1 line between any two rooms*/
        int offset = 3;

        // location check - if proposed room is out of bound, don't add the room
        if (row - (1 + Math.abs(offset)) < 0 || row + roomHEIGHT + (1 + Math.abs(offset)) >= HEIGHT || col - (1 + Math.abs(offset)) < 0 || col + roomWIDTH + (1 + Math.abs(offset)) >= WIDTH) {
            return; // exit method if the room is out of bound
        }
        // space check - if world still has enough space for the new room created, add the room; discard the room otherwise
        if (isSpaceEnough(world, row - (1 + offset), col - (1 + offset), roomWIDTH + 2 * (1 + offset), roomHEIGHT + 2 * (1 + offset))) {
            // add room
            /* room is generated by the following steps:
             * 1. add a layer of WALLs with roomWIDTH + 2 and roomHEIGHT + 2, at starting point (row-1, col-1)
             * 2. add a layer of space (eg, NOTHING) with roomWIDTH and roomHEIGHT, at starting point(row, col)
             */
            addWALLS(world, row - 1, col - 1, roomWIDTH + 2, roomHEIGHT + 2);
            for (int i = 2; i > 0; i--) {
                addDoor(world, row - 1, col - 1, roomWIDTH + 2, roomHEIGHT + 2);
            }
            addSpace(world, row, col, roomWIDTH, roomHEIGHT, Tileset.FLOOR);
        }
    }

    public boolean isSpaceEnough(TETile[][] world, int row, int col, int roomWIDTH, int roomHEIGHT) {
        for (int i = row; i < row + roomHEIGHT; i++) {
            for (int j = col; j < col + roomWIDTH; j++) {
                if (world[j][i] == Tileset.WALL || world[j][i] == Tileset.FLOOR) {
                    return false;
                }
            }
        }
        return true;
    }

    public void addWALLS(TETile[][] world, int row, int col, int wallWIDTH, int wallHEIGHT) {
        for (int i = row; i < row + wallHEIGHT; i++) {
            for (int j = col; j < col + wallWIDTH; j++) {
                world[j][i] = Tileset.WALL;
            }
        }
    }
    // add one door in each room
    public void addDoor(TETile[][] world, int row, int col, int wallWIDTH, int wallHEIGHT) {
        int cond = RANDOM.nextInt(4);
        int rowPos = row;
        int colPos = col + 1;
        switch(cond) {
            case 0:
                rowPos = row;
                colPos = RANDOM.nextInt(wallWIDTH - 2) + col + 1;
                break;
            case 1:
                rowPos = row + wallHEIGHT - 1;
                colPos = RANDOM.nextInt(wallWIDTH - 2) + col + 1;
                break;
            case 2:
                rowPos = RANDOM.nextInt(wallHEIGHT - 2) + row + 1;
                colPos = col;
                break;
            case 3:
                rowPos = RANDOM.nextInt(wallHEIGHT - 2) + row + 1;
                colPos = col + wallWIDTH - 1;
                break;
        }
        world[colPos][rowPos] = Tileset.UNLOCKED_DOOR;
    }

    public void addSpace(TETile[][] world, int row, int col, int spaceWIDTH, int spaceHEIGHT, TETile TileSetType) {
        for (int i = row; i < row + spaceHEIGHT; i++) {
            for (int j = col; j < col + spaceWIDTH; j++) {
                world[j][i] = TileSetType;
            }
        }

    }

    public void addSpace(TETile[][] world, int row, int col, int spaceWIDTH, int spaceHEIGHT) {
        addSpace(world, row, col, spaceWIDTH, spaceHEIGHT, Tileset.NOTHING);
    }

    /* add hallways in the world to connect rooms
     */
    public TETile[][] addHallways(TETile[][] world) {
        int rowPos;
        int colPos;
        for(rowPos = 1; rowPos < HEIGHT - 1; rowPos++) {
            for (colPos = 1; colPos < WIDTH - 1; colPos++) {
                if (isNeighborEmpty(rowPos, colPos, world)) {
                    world[colPos][rowPos] = Tileset.FLOOR;
                }
            }
        }
        return world;
    }

    /*  check the status of neighbours
     * return true, if nearby tiles are all empty (NOTHING)
     * return false, otherwise
     */
    private boolean isNeighborEmpty(int row, int col, TETile[][] world) {
        for (int i = -1; i < 2; i++) {
            int rowPos = Math.min(HEIGHT - 1, Math.max(0, row + i));
            for (int j = -1; j < 2; j++) {
                int colPos = Math.min(WIDTH - 1, Math.max(0, col + j));
                if (world[colPos][rowPos] != Tileset.NOTHING) {
                    return false;
                }
            }
        }
        return true;
    }

    /* random initialization */
    public TETile[][] worldInit(TETile[][] world) {
        for (int row = 0; row < HEIGHT; row++) {
            for (int col = 0; col < WIDTH; col++) {
                world[col][row] = Tileset.NOTHING;
            }
        }
        return world;
    }
}
